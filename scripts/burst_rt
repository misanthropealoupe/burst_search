#! /usr/bin/python

import time
import argparse
from os import path
import logging

import numpy as np
import h5py

from burst_search import guppi
from multiprocessing import Process
from burst_search import datasource
from burst_search.datasource import FileChimeSource
from burst_search.ringbuffer import RingBuffer
from burst_search.actionhandler import ActionHandler
import burst_search.search as search

# Command line arguments.
parser = argparse.ArgumentParser(description='Search real-time feed or chime-like data file for transients')
parser.add_argument(
	"files",
	metavar="input_dat_files",
	type=str,
	nargs='+',
	help="input .dat files to chunk",
	)
parser.add_argument(
	"--chunk_size",
	type=int,
	default=1024,
	)
parser.add_argument(
	"--min_dm",
	type=float,
	default=50.0,
	)
parser.add_argument(
	"--max_dm",
	type=float,
	default=500.0,
	)
parser.add_argument(
	"--snr_min",
	type=float,
	default=6.0,
	)
parser.add_argument(
	"--cadence",
	type=float,
	default=0.001
	)
parser.add_argument(
	"--ring_length",
	type=int,
	default=16*1024
	)
#Cadence sample units
parser.add_argument(
	"--chunk_length",
	type=int,
	default=1024
	)
parser.add_argument(
	"--bw",
	type=float,
	default=-400.0
	)

#def do_indef(ds, snr_min, min_dm,):
#	while(True):
#		dat = ds()
#		search.basic(dat, )

def do_forever(source,f):
	while source.active:
		f()

if __name__ == "__main__":
	args = parser.parse_args()
	files = args.files
	#chunk_size = args.chunk_size
	min_dm = args.min_dm
	max_dm = args.max_dm
	snr_min = args.snr_min
	cadence = args.cadence
	ring_length = args.ring_length
	chunk_length = args.chunk_length
	bw = args.bw

	for f in files:
		ah = ActionHandler(modes='save_plot_dm, print')
		#def __init__(self,chunk_size,buffer_size,delta_t, nfreq, freq0, delta_f, max_dm):
		ds = FileChimeSource(chunk_length, f)
		print "Using effective cadence: %f" % ds.set_num_packs(cadence)
		frame_cadence = datasource.frame_cadence
		npacks = ds.npacks
		rb = RingBuffer(chunk_length, ring_length, ds.eff_cadence, ds.nfreq, ds.freq0, bw/float(ds.nfreq),max_dm)

		rs = lambda: search.basic_triangle(rb(ds.get_intensity_cadence_block(chunk_length)), snr_threshold = snr_min, min_dm = min_dm)
		f = lambda: do_forever(ds,rs)

		p = Process(target=f)
		p.start()
		p.join()
		#p.jo

